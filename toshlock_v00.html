<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ToshLock ‚Äî Lock & Manage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--bg:#0c1222;--fg:#fff;--card:rgba(255,255,255,.06);--border:rgba(255,255,255,.12)}
    body{background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;margin:0}
    .wrap{max-width:1050px;margin:32px auto;padding:0 18px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px}
    input,button{border-radius:10px;padding:10px 12px;border:1px solid var(--border);background:#0f1730;color:#fff}
    button{cursor:pointer;border:0}
    .btn{background:#3b82f6} .btn.alt{background:#16a34a} .btn.gray{background:#6b7280}
    table{width:100%;border-collapse:collapse} th,td{padding:8px;border-bottom:1px solid var(--border);font-size:13px}
    th{text-align:left;background:#0b1226}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
    .muted{opacity:.85;font-size:12px}
  </style>

  <!-- ethers v5 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- your self-hosted WalletConnect v2 provider bundle -->
  <script src="assets/walletconnect.min.js"></script>
</head>
<body>
<div class="wrap">
  <header class="row" style="justify-content:space-between">
    <h1>üîí ToshLock ‚Äî Lock & Manage</h1>
    <div class="row">
      <button id="mm"  class="btn alt">MetaMask</button>
      <button id="wc"  class="btn">WalletConnect</button>
      <button id="disc" class="btn gray" disabled>Disconnect</button>
    </div>
  </header>
  <div id="status" class="muted" style="margin:6px 0 18px">Not connected</div>

  <!-- Lock form -->
  <section class="card" style="margin-bottom:16px">
    <h2 style="margin-top:0">Create a lock</h2>

    <div style="margin:8px 0">
      <div class="muted" style="margin-bottom:6px">Token address</div>
      <input id="token" class="mono" placeholder="0x... token" style="width:100%">
      <div id="tokenMeta" class="muted">‚Äî</div>
    </div>

    <div class="row" style="margin:8px 0">
      <div style="flex:1 1 280px">
        <div class="muted" style="margin-bottom:6px">Amount (human)</div>
        <input id="amount" type="number" step="any" placeholder="e.g. 1000" style="width:100%">
        <div id="amountHint" class="muted">‚Äî</div>
      </div>
      <div style="flex:1 1 280px">
        <div class="muted" style="margin-bottom:6px">Lock until (local time)</div>
        <input id="when" type="datetime-local" style="width:100%">
      </div>
    </div>

    <div style="margin:8px 0">
      <div class="muted" style="margin-bottom:6px">Lock name (optional)</div>
      <input id="lname" placeholder="Liquidity Round #1" style="width:100%">
    </div>

    <div class="row" style="margin-top:10px">
      <button id="approveLock" class="btn">Approve & Lock</button>
      <span class="muted">Fee ~3% goes to owner; remainder is locked.</span>
    </div>
    <pre id="txlog" class="card" style="margin-top:12px;height:160px;overflow:auto"></pre>
  </section>

  <!-- My Locks -->
  <section class="card">
    <div class="row" style="justify-content:space-between">
      <h2 style="margin:0">My Locks</h2>
      <button id="scan" class="btn gray">Scan</button>
    </div>

    <div class="row" style="margin-top:10px">
      <div style="flex:1 1 480px">
        <h3 style="margin-top:0">Active</h3>
        <div class="card" style="padding:0">
          <table>
            <thead>
              <tr>
                <th>Lock ID</th><th>Token</th><th>Name</th>
                <th style="text-align:right">Amount</th><th>Symbol</th><th>Unlock</th>
              </tr>
            </thead>
            <tbody id="activeRows"></tbody>
          </table>
        </div>
      </div>
      <div style="flex:1 1 480px">
        <h3 style="margin-top:0">Unlockable</h3>
        <div class="card" style="padding:0">
          <table>
            <thead>
              <tr>
                <th>Lock ID</th><th>Token</th><th>Name</th>
                <th style="text-align:right">Amount</th><th>Symbol</th><th>Unlock</th><th>Action</th>
              </tr>
            </thead>
            <tbody id="unlockableRows"></tbody>
          </table>
        </div>
      </div>
    </div>

    <pre id="scanlog" class="card" style="margin-top:12px;height:160px;overflow:auto"></pre>
  </section>
</div>

<script>
/* ========= Hardcoded env ========= */
const LOCKER = "0xdAafaf8fC73C6D4dfE27B2494Bdc864D0f7C9c01";
const RPC    = "https://rpc-pepu-v2-testnet-vn4qxxp9og.t.conduit.xyz";
const CHAIN  = 97741;
const WC_PID = "6e2df48125e4f633b093361ba0a87c81";
const FROM_BLOCK = 97740;

/* ========= ABIs ========= */
const ERC20 = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function approve(address spender,uint256 amount) returns (bool)"
];
const LOCKER_ABI = [
  "event LiquidityLocked(address indexed token,address indexed user,uint256 indexed lockId,uint256 amount,uint256 unlockTime,string name)",
  "event LiquidityUnlocked(address indexed token,address indexed user,uint256 indexed lockId,uint256 amount)",
  "function lockLiquidity(address token,uint256 amount,uint256 lockTime)",
  "function lockLiquidityWithName(address token,uint256 amount,uint256 lockTime,string name)",
  "function getLock(address token,address user,uint256 lockId) view returns (uint256 amount,uint256 unlockTime,string name)",
  "function unlockLiquidity(address token,uint256 lockId)"
];

/* ========= Utils ========= */
const $ = id => document.getElementById(id);
const logTx = (...a)=>{ $("txlog").textContent += a.join(" ")+"\n"; };
const logScan = (...a)=>{ $("scanlog").textContent += a.join(" ")+"\n"; };
const setStatus = (s)=>{ $("status").textContent = s; };

let providerType = null; // 'mm' | 'wc'
let wcProvider, ethersProvider, signer;
const roProvider = new ethers.providers.JsonRpcProvider(RPC);

/* ========= Connect buttons ========= */
$("mm").onclick = async () => {
  try {
    if (!window.ethereum) throw new Error("MetaMask not found");
    providerType = 'mm';
    ethersProvider = new ethers.providers.Web3Provider(window.ethereum, 'any');
    await ethersProvider.send('eth_requestAccounts', []);
    signer = ethersProvider.getSigner();
    const a = await signer.getAddress();
    const n = await ethersProvider.getNetwork();
    setStatus(`Connected (MM): ${a.slice(0,6)}‚Ä¶${a.slice(-4)} on chain ${n.chainId}`);
    $("disc").disabled = false;
  } catch(e){ setStatus(e.message||String(e)); }
};

$("wc").onclick = async () => {
  try {
    if (!window.WalletConnectEthereumProvider) throw new Error("walletconnect.min.js missing");
    providerType = 'wc';
    wcProvider = await window.WalletConnectEthereumProvider.init({
      projectId: WC_PID, showQrModal: true,
      chains:[CHAIN], optionalChains:[CHAIN],
      rpcMap: { [CHAIN]: RPC },
      metadata: { name:"ToshLock", description:"Lock tokens with ToshLock", url:location.origin, icons:["https://walletconnect.com/walletconnect-logo.png"] }
    });
    await wcProvider.enable();
    ethersProvider = new ethers.providers.Web3Provider(wcProvider,'any');
    signer = ethersProvider.getSigner();
    const a = await signer.getAddress();
    const n = await ethersProvider.getNetwork();
    setStatus(`Connected (WC): ${a.slice(0,6)}‚Ä¶${a.slice(-4)} on chain ${n.chainId}`);
    $("disc").disabled = false;

    wcProvider.on('disconnect', ()=>{ setDisconnectedUI(); });
  } catch(e){ setStatus(e.message||String(e)); }
};

$("disc").onclick = async () => {
  try {
    if (providerType === 'wc' && wcProvider?.disconnect) await wcProvider.disconnect();
  } catch {}
  setDisconnectedUI();
};
function setDisconnectedUI(){
  providerType = null; wcProvider = ethersProvider = signer = undefined;
  setStatus("Not connected");
  $("disc").disabled = true;
}

/* ========= Token meta auto-read ========= */
let tokenDecimals=null, tokenSymbol="", tokenName="";
async function refreshTokenMeta(){
  const addr = $("token").value.trim();
  if(!/^0x[a-fA-F0-9]{40}$/.test(addr)){ $("tokenMeta").textContent="‚Äî"; $("amountHint").textContent="‚Äî"; tokenDecimals=null; return; }
  try{
    const t = new ethers.Contract(addr, ERC20, roProvider);
    const [name,symbol,dec] = await Promise.all([t.name(), t.symbol(), t.decimals()]);
    tokenName=name; tokenSymbol=symbol; tokenDecimals=Number(dec);
    $("tokenMeta").textContent = `${name} (${symbol}), decimals=${tokenDecimals}`;
    const human = $("amount").value || "0";
    $("amountHint").textContent = `= ${ethers.utils.parseUnits(human, tokenDecimals).toString()} base units`;
  }catch{ $("tokenMeta").textContent="‚ö†Ô∏è cannot read token"; tokenDecimals=null; }
}
$("token").addEventListener("change", refreshTokenMeta);
$("token").addEventListener("blur", refreshTokenMeta);
$("amount").addEventListener("input", ()=>{
  if(tokenDecimals==null){ $("amountHint").textContent="enter a valid token first"; return; }
  try{ $("amountHint").textContent = `= ${ethers.utils.parseUnits($("amount").value||"0", tokenDecimals).toString()} base units`; }catch{ $("amountHint").textContent="‚Äî"; }
});

/* ========= Approve & Lock ========= */
$("approveLock").onclick = async () => {
  try{
    if(!signer) throw new Error("Connect wallet first");
    if(tokenDecimals==null) await refreshTokenMeta();

    const tokenAddr = ethers.utils.getAddress($("token").value.trim());
    const amtHuman  = $("amount").value || "0";
    const amount    = ethers.utils.parseUnits(amtHuman, tokenDecimals||18);

    const v = $("when").value;
    if(!v) throw new Error("Pick a future lock date/time");
    const unlockTs = Math.floor(Date.parse(v)/1000);
    if(!unlockTs || unlockTs <= Math.floor(Date.now()/1000)) throw new Error("Lock time must be in the future");

    const name = $("lname").value || "";

    const erc = new ethers.Contract(tokenAddr, ERC20, signer);
    const tx1 = await erc.approve(LOCKER, amount);
    logTx("Approval:", tx1.hash); await tx1.wait(); logTx("‚úÖ Approval confirmed");

    const locker = new ethers.Contract(LOCKER, LOCKER_ABI, signer);
    const fn = locker.lockLiquidityWithName ?? locker.lockLiquidity;
    const tx2 = await fn(tokenAddr, amount, unlockTs, name);
    logTx("Lock:", tx2.hash); await tx2.wait(); logTx("üîí Lock confirmed");

    scanMyLocks(); // refresh
  }catch(e){ logTx("‚ùå", e?.data?.message || e?.message || String(e)); }
};

/* ========= My Locks scan + unlock ========= */
const activeRows = $("activeRows"), unlockableRows = $("unlockableRows");

async function scanMyLocks(){
  try{
    if(!signer) throw new Error("Connect wallet first");
    $("scanlog").textContent=""; logScan("Scanning‚Ä¶");
    activeRows.innerHTML=""; unlockableRows.innerHTML="";

    const user = await signer.getAddress();
    const lockerRO = new ethers.Contract(LOCKER, LOCKER_ABI, roProvider);

    const iface = new ethers.utils.Interface(LOCKER_ABI);
    const topicLocked = iface.getEventTopic("LiquidityLocked");
    const userTopic = ethers.utils.hexZeroPad(user, 32);

    const latest = await roProvider.getBlockNumber();
    const CHUNK=50_000; let logs=[];
    for(let start=FROM_BLOCK; start<=latest; start+=CHUNK){
      const end = Math.min(start+CHUNK-1, latest);
      const part = await roProvider.getLogs({address:LOCKER, fromBlock:start, toBlock:end, topics:[topicLocked, null, userTopic]});
      logs = logs.concat(part);
    }
    logScan("events:", logs.length);

    const metaCache=new Map();
    const tokenInfo = async (addr)=>{
      const k=addr.toLowerCase(); if(metaCache.has(k)) return metaCache.get(k);
      try{
        const erc=new ethers.Contract(addr, ERC20, roProvider);
        const [sym,dec]=await Promise.all([erc.symbol().catch(()=>"?"), erc.decimals().catch(()=>18)]);
        const v={sym,dec:Number(dec)}; metaCache.set(k,v); return v;
      }catch{return {sym:"?",dec:18}}
    };

    const now = Math.floor(Date.now()/1000);
    for(const lg of logs){
      let ev; try{ ev=iface.parseLog(lg); }catch{ continue; }
      const token = ev.args.token;
      const lockId = ev.args.lockId.toNumber();

      let amount, unlockTime, name;
      try{
        const res = await lockerRO.getLock(token, user, lockId);
        amount = res.amount ?? res[0];
        unlockTime = (res.unlockTime ?? res[1]);
        name = res.name ?? res[2];
      }catch{ continue; }

      if(!amount || amount.toString()==="0") continue; // already unlocked

      const meta = await tokenInfo(token);
      const human = ethers.utils.formatUnits(amount, meta.dec);
      const date  = new Date(unlockTime.toNumber()*1000).toLocaleString();

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${lockId}</td>
        <td class="mono">${token.slice(0,6)}‚Ä¶${token.slice(-4)}</td>
        <td>${name||""}</td>
        <td style="text-align:right">${Number(human).toLocaleString()}</td>
        <td>${meta.sym}</td>
        <td>${date}</td>
      `;

      if (unlockTime.toNumber() > now) {
        activeRows.appendChild(tr);
      } else {
        const td = document.createElement("td");
        const btn = document.createElement("button");
        btn.textContent="Unlock"; btn.className="btn alt";
        btn.onclick = async ()=>{
          try{
            const locker = new ethers.Contract(LOCKER, LOCKER_ABI, signer);
            btn.disabled=true; btn.textContent="Unlocking‚Ä¶";
            const tx = await locker.unlockLiquidity(token, lockId);
            logScan("Unlock:", tx.hash);
            await tx.wait();
            logScan("‚úÖ Unlocked", lockId);
            scanMyLocks();
          }catch(e){ logScan("‚ùå", e?.data?.message || e?.message || String(e)); btn.disabled=false; btn.textContent="Unlock"; }
        };
        td.appendChild(btn); tr.appendChild(td);
        unlockableRows.appendChild(tr);
      }
    }
    logScan("Done.");
  }catch(e){ logScan("‚ùå", e?.data?.message || e?.message || String(e)); }
}
$("scan").onclick = scanMyLocks;
</script>
</body>
</html>
